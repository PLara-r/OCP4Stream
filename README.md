# OCP4Stream

1) Потоковый конвейер состоит из трех частей. Требуется источник, и он создает данные в потоке.
Может быть ноль или более промежуточных операций, которые не выполняются, пока не завершится операция терминала.
Примеры промежуточных операций включают в себя filter(), flatMap()и sorted().
Примеры концевых операций включают в себя allMatch(), count()и forEach().

Поиск потока. 
findFirst()И findAny()методы возвращают один элемент из потока в Optional. anyMatch(), allMatch()И noneMatch()методы возвращают boolean.
Будьте осторожны, потому что эти три могут зависнуть, если их вызвать в бесконечном потоке с некоторыми данными. 
Все эти методы являются терминальными операциями.

Сортировать поток. 
sorted()Метод является промежуточной операцией , которая сортирует поток.
Существует две версии: подпись с нулевыми параметрами, которая сортирует с использованием естественного порядка сортировки,
и подпись с одним параметром, который сортирует с использованием этого Comparatorв качестве порядка сортировки.

2) Использование общих операций терминала

Вы можете выполнить терминальную операцию без каких-либо промежуточных операций, но не наоборот. Вот почему мы сначала поговорим о терминальных операциях. Reductionsэто особый тип терминальной операции, где все содержимое потока объединено в один примитив или Object. Например, вы можете иметь intили Collection.
Таблица 4.4 суммирует этот раздел. Не стесняйтесь использовать его в качестве руководства для запоминания самых важных моментов, когда мы проходим каждый из них в отдельности. Мы объясняем их от простого к сложному, а не в алфавитном порядке.
Таблица 4.4 Операции с терминальным потоком

метод	Что происходит для бесконечных потоков	Возвращаемое значение	снижение
allMatch() /anyMatch() /noneMatch()	Иногда заканчивается	boolean	нет
collect()	Не заканчивается	Различная
Varies	да
count()	Не заканчивается	long	да
findAny() /findFirst()	Завершает	Optional<T>	нет
forEach()	Не заканчивается	void	нет
min()/max()	Не заканчивается	Optional<T>	да
reduce()	Не заканчивается	Различная
Varies	да

кол-()
count()Метод определяет количество элементов в конечном потоке. Для бесконечного потока это зависает. Почему? Считайте от 1 до бесконечности и дайте нам знать, когда вы закончите. Вернее, не делайте этого, потому что мы бы предпочли, чтобы вы готовились к экзамену, а не тратили всю оставшуюся жизнь на счет. count()является сокращением, потому что он смотрит на каждый элемент в потоке и возвращает одно значение. Подпись метода такова:
long count()
В этом примере показано обращение count()к конечному потоку:

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count());     // 3
min () и max ()
min()И max()методы позволяют передавать пользовательские компаратор и найти наименьшее или наибольшее значение в конечном потоке в соответствии с этим порядок сортировки. Как count(), min()и max()повесьте на бесконечном потоке , потому что они не могут быть уверены , что больше или меньше значение не приходит позже в потоке. Оба метода являются сокращениями, потому что они возвращают одно значение после просмотра всего потока. Подписи метода следующие:

Optional<T> min(<? super T> comparator)
Optional<T> max(<? super T> comparator)
Этот пример находит животное с наименьшим количеством букв в его названии:

Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length()—s2.length());
min.ifPresent(System.out::println); // ape
Обратите внимание, что код возвращает Optionalскорее значение, чем значение. Это позволяет методу указывать, что ни минимум, ни максимум не найдены. Мы используем Optionalметод и ссылку на метод, чтобы распечатать минимум, только если он найден. В качестве примера, где нет минимума, давайте посмотрим на пустой поток:

Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent());    // false
Поскольку поток пуст, компаратор никогда не вызывается, и в Optional. 
 findAny () и findFirst ()
findAny()И findFirst()методы возвращают элемент потока , если поток не пуст. Если поток пуст, они возвращают пустое Optional. Это первый метод, который вы видели, который работает с бесконечным потоком. Поскольку Java генерирует только необходимое вам количество потока, бесконечный поток должен генерировать только один элемент. findAny()полезно, когда вы работаете с параллельным потоком. Это дает Java возможность гибко возвращать вам первый элемент, а не тот, который должен быть первым в потоке на основе промежуточных операций.
Эти методы являются терминальными операциями, но не сокращениями. Причина в том, что они иногда возвращаются без обработки всех элементов. Это означает, что они возвращают значение на основе потока, но не сводят весь поток к одному значению.
Сигнатуры метода таковы:

Optional<T> findAny()
Optional<T> findFirst()

Этот пример находит животное:
Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey
infinite.findAny().ifPresent(System.out::println); // chimp

Поиск любого совпадения полезнее, чем кажется. Иногда мы просто хотим проверить результаты и получить репрезентативный элемент, но нам не нужно тратить впустую обработку, генерирующую их все. В конце концов, если мы планируем работать только с одним элементом, зачем смотреть дальше? 
 allMatch () , anyMatch () и noneMatch ()
В allMatch(), anyMatch()и noneMatch()методы поиска потока и возврата информации о том , как поток относится к предикату. Они могут заканчиваться или не заканчиваться для бесконечных потоков. Это зависит от данных. Как и методы поиска, они не являются сокращениями, потому что они не обязательно смотрят на все элементы.
Подписи метода следующие:

boolean anyMatch(Predicate <? super T> predicate)
boolean allMatch(Predicate <? super T> predicate)
boolean noneMatch(Predicate <? super T> predicate)

Этот пример проверяет, начинаются ли имена животных с букв:

List<String> list = Arrays.asList("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true
Это показывает, что мы можем повторно использовать один и тот же предикат, но каждый раз нам нужен другой поток. anyMatch()возвращается, trueпотому что два из трех элементов совпадают. allMatch()возвращается, falseпотому что один не совпадает. noneMatch()также возвращается, falseпотому что один соответствует. В бесконечном списке найдено одно совпадение, поэтому вызов завершается. Если мы позвоним noneMatch()или allMatch(), они будут работать, пока мы не убьём программу.     
Помните , что allMatch(), anyMatch()и noneMatch()возвращать boolean. Методы поиска, напротив, возвращают, Optionalпотому что они возвращают элемент потока.
  для каждого()
Циклическая конструкция доступна. Как и ожидалось, вызов forEach()в бесконечном потоке не завершается. Поскольку нет возвращаемого значения, это не сокращение.
Прежде чем использовать его, подумайте, будет ли лучше другой подход. Разработчики, которые сначала научились писать циклы, как правило, используют их для всего. Например, ifвместо этого цикл с оператором должен быть фильтром.
Подпись метода следующая:

void forEach(Consumer<? super T> action)
Обратите внимание, что это единственная терминальная операция с типом возврата void. Если вы хотите, чтобы что-то произошло, вы должны сделать это в цикле. Вот один из способов печати элементов в потоке. Есть и другие способы, которые мы рассмотрим позже в этой главе.

Stream<String> s = Stream.of("Monkey", "Gorilla", "Bonobo");
s.forEach(System.out::print);    // MonkeyGorillaBonobo
Помните, что вы можете позвонить forEach()прямо на Collectionили на Stream. Не запутайтесь на экзамене, когда увидите оба подхода.
Обратите внимание, что вы не можете использовать традиционный forцикл в потоке:

Stream s = Stream.of(1);
for (Integer i: s) {} // DOES NOT COMPILE
Хотя это forEach()звучит как цикл, это действительно оператор терминала для потоков. Потоки не могут использовать традиционный forцикл для запуска, потому что они не реализуют Iterableинтерфейс.  уменьшения ()
reduce()
Метод сочетает в себе поток в единый объект. Как видно из названия, это сокращение. Сигнатуры метода таковы:

T reduce(T identity, BinaryOperator<T> accumulator)
Optional<T> reduce(BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)

Давайте принимать их по одному. Наиболее распространенный способ сделать сокращение - начать с начального значения и продолжать объединять его со следующим значением. Подумайте, как вы могли бы объединить массив Strings в один Stringбез функционального программирования. Это может выглядеть примерно так:

String[] array = new String[] { "w", "o", "l", "f" };
String result = "";
for (String s: array) result = result + s;
System.out.println(result);
Давайте принимать их по одному. Наиболее распространенный способ сделать сокращение - начать с начального значения и продолжать объединять его со следующим значением. Подумайте, как вы могли бы объединить массив Strings в один Stringбез функционального программирования. Это может выглядеть примерно так:

Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word);    // wolf
Обратите внимание, что у нас все еще есть пустая Stringличность. Мы также все еще объединяем Strings, чтобы получить следующее значение. Мы можем даже переписать это с помощью ссылки на метод:

Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word);    // wolf
Давайте попробуем еще один. Можете ли вы написать сокращение, чтобы умножить все Integerобъекты в потоке? Попробуй это. Наше решение показано здесь:

Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a*b));
Мы устанавливаем личность 1и аккумулятор для умножения. Во многих случаях идентичность на самом деле не нужна, поэтому Java позволяет нам ее опускать. Когда вы не указываете идентификатор, Optionalвозвращается, потому что может не быть никаких данных. Есть три варианта того, что находится в Optional:
•	Если поток пустой, Optionalвозвращается пустой .
•	Если поток имеет один элемент, он возвращается.
•	Если поток имеет несколько элементов, аккумулятор применяется для их объединения.
Следующее иллюстрирует каждый из этих сценариев:

BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);
 empty.reduce(op).ifPresent(System.out::print); // no
 outputoneElement.reduce(op).ifPresent(System.out::print); // 3
threeElements.reduce(op).ifPresent(System.out::print); // 90
Почему есть два похожих метода? Почему бы просто не всегда требовать личность? Ява могла бы сделать это. Однако иногда полезно различать случай, когда поток пуст, а не случай, когда существует значение, которое соответствует идентификатору, возвращаемому из расчета. Возвращаемая подпись Optionalпозволяет нам дифференцировать эти случаи. Например, мы можем вернуть, Optional.empty()когда поток пуст и Optional.of(3)когда есть значение.
Третий метод подписи используется, когда мы обрабатываем коллекции параллельно. Это позволяет Java создавать промежуточные сокращения, а затем объединять их в конце. В нашем примере это выглядит аналогично. Хотя здесь мы на самом деле не используем параллельный поток, Java предполагает, что поток может быть параллельным. Это полезно, потому что это позволяет нам легко переключаться на параллельный поток в будущем:

BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, op, op)); // 90
собирать ()
collect()Метод представляет собой особый тип редукции называется mutable reduction. Это более эффективно, чем обычное сокращение, потому что мы используем тот же изменяемый объект, в то время какнакопления. Общие изменяемые объекты включают StringBuilderи ArrayList. Это действительно полезный метод, потому что он позволяет нам выводить данные из потоков в другую форму. Подписи метода следующие:

<R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)
<R,A> R collect(Collector<? super T, A,R> collector)
Давайте начнем с первой сигнатуры, которая используется, когда мы хотим конкретно написать, как должен работать сбор. Наш пример волка из reduceможет быть преобразован в использование collect():

Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(StringBuilder::new, 
  StringBuilder::append, StringBuilder:append)
Первый параметр - это Supplierобъект, который создает объект, который будет хранить результаты по мере сбора данных. Помните, что a Supplierне принимает никаких параметров и возвращает значение. В этом случае он конструирует новый StringBuilder.
Второй параметр - это a BiConsumer, который принимает два параметра и ничего не возвращает. Он отвечает за добавление еще одного элемента в сбор данных. В этом примере он добавляет следующий Stringк StringBuilder.
Последний параметр другой BiConsumer. Он отвечает за сбор и объединение двух данных. Это полезно, когда мы обрабатываем параллельно. Две меньшие коллекции формируются и затем объединяются в одну. Это будет работать StringBuilderтолько в том случае, если мы не заботимся о порядке букв. В этом случае аккумулятор и сумматор имеют сходную логику.
Теперь давайте посмотрим на пример, где логика отличается в аккумуляторе и сумматоре:

Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(TreeSet::new, TreeSet::add, TreeSet::addAll);
System.out.println(set); // [f, l, o, w]
Коллектор состоит из трех частей, как и раньше. Поставщик создает пустую TreeSet. Аккумулятор добавляет один Stringиз Streamк TreeSet. Объединитель добавляет все элементы одного TreeSetк другому, если операции выполнялись параллельно и их необходимо объединить.
Мы начали с длинной подписи, потому что именно так вы реализуете свой собственный сборщик. Важно знать, как это сделать на экзамене, и понять, как работают коллекционеры. На практике есть много общих коллекционеров, которые появляются снова и снова. Вместо того, чтобы заставлять разработчиков продолжать реализовывать одни и те же, Java предоставляет интерфейс с общими сборщиками. Этот подход также облегчает чтение кода, поскольку он более выразителен. Например, мы могли бы переписать предыдущий пример следующим образом:

Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]
Если бы нам не нужно было сортировать набор, мы могли бы сделать код еще короче:
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
Вы можете получить другой вывод для этого последнего, так как не toSet()дает никаких гарантий относительно того, какую реализацию Setвы получите. Это может быть HashSet, но вы не должны ожидать или полагаться на это.  
   

